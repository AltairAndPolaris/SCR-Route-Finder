<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Transit Route Planner</title>
<style>
body {
    font-family: Arial, sans-serif;
    background: #f4f6fa;
    padding: 20px;
}
.section {
    background: white;
    padding: 15px;
    margin-bottom: 15px;
    border-radius: 6px;
}
.route {
    margin-top: 10px;
    padding-left: 10px;
    border-left: 3px solid #4a6cf7;
}
.transfer {
    color: #c0392b;
    font-weight: bold;
}
</style>
</head>
<body>

<h1>Transit Route Planner</h1>

<div class="section">
    From: <select id="from"></select>
    To: <select id="to"></select>
</div>

<div class="section">
    <h3>Operator pricing (per station)</h3>
    <div id="pricing"></div>
</div>

<button onclick="compute()">Compute routes</button>

<div class="section">
    <h2>Results</h2>
    <div id="output"></div>
</div>

<script>
/* =======================
   PARSE route.txt
======================= */

function parseRouteFile(text) {
    const graph = new Map();
    const stations = new Set();
    const operators = new Set();

    function addEdge(from, to, route, operator, time) {
        if (!graph.has(from)) graph.set(from, []);
        graph.get(from).push({ to, route, operator, time });
    }

    const routes = text.split("//").filter(r => r.trim());

    for (const r of routes) {
        const [operator, routeId, stationPart] = r.split("/");
        operators.add(operator);

        const list = stationPart.split(";").map(s => {
            const [name, t] = s.split(",");
            return { name, time: Number(t) };
        });

        for (let i = 0; i < list.length - 1; i++) {
            const a = list[i];
            const b = list[i + 1];
            const dt = b.time - a.time;

            addEdge(a.name, b.name, routeId, operator, dt);
            addEdge(b.name, a.name, routeId, operator, dt);

            stations.add(a.name);
            stations.add(b.name);
        }
    }

    return { graph, stations: [...stations], operators: [...operators] };
}

/* =======================
   PRIORITY QUEUE
======================= */

class PriorityQueue {
    constructor(compare) {
        this.data = [];
        this.compare = compare;
    }
    push(x) {
        this.data.push(x);
        this.data.sort(this.compare);
    }
    pop() {
        return this.data.shift();
    }
    get size() {
        return this.data.length;
    }
}

/* =======================
   PATHFINDING
======================= */

function findPath(graph, from, to, mode, pricing) {
    const TRANSFER_PENALTY = 5;

    const pq = new PriorityQueue((a, b) => {
        if (mode === "direct") {
            if (a.transfers !== b.transfers)
                return a.transfers - b.transfers;
            return a.time - b.time;
        }
        if (mode === "cheap") return a.cost - b.cost;
        return (a.time + a.transfers * TRANSFER_PENALTY) -
               (b.time + b.transfers * TRANSFER_PENALTY);
    });

    const best = new Map();

    for (const e of graph.get(from) || []) {
        const s = {
            station: from,
            route: e.route,
            operator: e.operator,
            time: 0,
            transfers: 0,
            cost: 0,
            path: []
        };
        best.set(from + "|" + e.route, s);
        pq.push(s);
    }

    while (pq.size) {
        const cur = pq.pop();
        if (cur.station === to) return cur;

        for (const e of graph.get(cur.station) || []) {
            const transfer = e.route !== cur.route;
            const next = {
                station: e.to,
                route: e.route,
                operator: e.operator,
                time: cur.time + e.time,
                transfers: cur.transfers + (transfer ? 1 : 0),
                cost: cur.cost + (pricing[e.operator] || 0),
                path: cur.path.concat({
                    from: cur.station,
                    to: e.to,
                    route: e.route,
                    operator: e.operator,
                    time: e.time,
                    transfer
                })
            };

            const key = e.to + "|" + e.route;
            const prev = best.get(key);

            let better = false;
            if (!prev) better = true;
            else if (mode === "direct")
                better = next.transfers < prev.transfers ||
                         (next.transfers === prev.transfers && next.time < prev.time);
            else if (mode === "cheap")
                better = next.cost < prev.cost;
            else
                better = next.time + next.transfers * 5 <
                         prev.time + prev.transfers * 5;

            if (better) {
                best.set(key, next);
                pq.push(next);
            }
        }
    }
    return null;
}

/* =======================
   UI
======================= */

let GRAPH, OPERATORS;

fetch("route.txt")
    .then(r => r.text())
    .then(text => {
        const { graph, stations, operators } = parseRouteFile(text);
        GRAPH = graph;
        OPERATORS = operators;

        const from = document.getElementById("from");
        const to = document.getElementById("to");

        stations.forEach(s => {
            from.add(new Option(s, s));
            to.add(new Option(s, s));
        });

        const pricingDiv = document.getElementById("pricing");
        operators.forEach(op => {
            pricingDiv.innerHTML +=
                `${op}: <input type="number" id="price_${op}" value="10"><br>`;
        });
    })
    .catch(err => {
        document.body.innerHTML =
            "<h2>Failed to load route.txt</h2><p>Make sure the file is in the same directory.</p>";
        console.error(err);
    });

function compute() {
    const from = document.getElementById("from").value;
    const to = document.getElementById("to").value;

    const pricing = {};
    OPERATORS.forEach(op => {
        pricing[op] = Number(document.getElementById("price_" + op).value);
    });

    const out = document.getElementById("output");
    out.innerHTML = "";

    render("Balanced route", findPath(GRAPH, from, to, "balanced", pricing));
    render("Most direct route", findPath(GRAPH, from, to, "direct", pricing));
    render("Cheapest route", findPath(GRAPH, from, to, "cheap", pricing));
}

function render(title, r) {
    const out = document.getElementById("output");
    if (!r) {
        out.innerHTML += `<h3>${title}</h3><p>No route found</p>`;
        return;
    }

    let html = `<h3>${title}</h3>`;
    html += `<p>Time: ${r.time} min | Transfers: ${r.transfers} | Cost: ${r.cost}</p>`;
    html += `<div class="route">`;

    r.path.forEach(p => {
        if (p.transfer)
            html += `<div class="transfer">Change to ${p.route}</div>`;
        html += `${p.from} â†’ ${p.to} (${p.route}, ${p.time} min)<br>`;
    });

    html += "</div>";
    out.innerHTML += html;
}
</script>

</body>
</html>
