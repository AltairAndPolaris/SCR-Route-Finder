<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Transit Route Planner</title>
<style>
body {
    font-family: Arial, sans-serif;
    background: #f4f6fa;
    padding: 20px;
}
h1 {
    margin-bottom: 10px;
}
input, select, button {
    padding: 6px;
    margin: 4px;
}
.section {
    background: white;
    padding: 15px;
    margin-bottom: 15px;
    border-radius: 6px;
}
.route {
    margin-top: 10px;
    padding-left: 10px;
    border-left: 3px solid #4a6cf7;
}
.transfer {
    color: #c0392b;
    font-weight: bold;
}
</style>
</head>
<body>

<h1>Transit Route Planner</h1>

<div class="section">
    <input type="file" id="fileInput">
</div>

<div class="section">
    From: <select id="from"></select>
    To: <select id="to"></select>
</div>

<div class="section">
    <h3>Operator pricing (per station)</h3>
    <div id="pricing"></div>
</div>

<button onclick="compute()">Compute routes</button>

<div class="section">
    <h2>Results</h2>
    <div id="output"></div>
</div>

<script>
/* =======================
   GRAPH PARSING
======================= */

function parseRouteFile(text) {
    const graph = new Map();
    const stations = new Set();
    const operators = new Set();

    function addEdge(from, to, route, operator, time) {
        if (!graph.has(from)) graph.set(from, []);
        graph.get(from).push({ to, route, operator, time });
    }

    const routes = text.split("//").filter(r => r.trim());

    for (const r of routes) {
        const [operator, routeId, stationPart] = r.split("/");
        operators.add(operator);

        const stationsList = stationPart.split(";")
            .map(s => {
                const [name, t] = s.split(",");
                return { name, time: Number(t) };
            });

        for (let i = 0; i < stationsList.length - 1; i++) {
            const a = stationsList[i];
            const b = stationsList[i + 1];
            const dt = b.time - a.time;

            addEdge(a.name, b.name, routeId, operator, dt);
            addEdge(b.name, a.name, routeId, operator, dt);

            stations.add(a.name);
            stations.add(b.name);
        }
    }

    return { graph, stations: [...stations], operators: [...operators] };
}

/* =======================
   PRIORITY QUEUE
======================= */

class PriorityQueue {
    constructor(compare) {
        this.data = [];
        this.compare = compare;
    }
    push(x) {
        this.data.push(x);
        this.data.sort(this.compare);
    }
    pop() {
        return this.data.shift();
    }
    get size() {
        return this.data.length;
    }
}

/* =======================
   PATHFINDER
======================= */

function findPath(graph, from, to, mode, pricing) {
    const TRANSFER_PENALTY = 5;

    const pq = new PriorityQueue((a, b) => {
        if (mode === "direct") {
            if (a.transfers !== b.transfers)
                return a.transfers - b.transfers;
            return a.time - b.time;
        }
        if (mode === "cheap") {
            return a.cost - b.cost;
        }
        return (a.time + a.transfers * TRANSFER_PENALTY) -
               (b.time + b.transfers * TRANSFER_PENALTY);
    });

    const best = new Map();

    for (const e of graph.get(from) || []) {
        const s = {
            station: from,
            route: e.route,
            operator: e.operator,
            time: 0,
            transfers: 0,
            cost: 0,
            path: []
        };
        best.set(from + "|" + e.route, s);
        pq.push(s);
    }

    while (pq.size) {
        const cur = pq.pop();
        if (cur.station === to) return cur;

        for (const e of graph.get(cur.station) || []) {
            const transfer = e.route !== cur.route;
            const next = {
                station: e.to,
                route: e.route,
                operator: e.operator,
                time: cur.time + e.time,
                transfers: cur.transfers + (transfer ? 1 : 0),
                cost: cur.cost + (pricing[e.operator] || 0),
                path: cur.path.concat({
                    from: cur.station,
                    to: e.to,
                    route: e.route,
                    operator: e.operator,
                    time: e.time,
                    transfer
                })
            };

            const key = e.to + "|" + e.route;
            const prev = best.get(key);

            let better = false;
            if (!prev) better = true;
            else if (mode === "direct")
                better = next.transfers < prev.transfers ||
                        (next.transfers === prev.transfers && next.time < prev.time);
            else if (mode === "cheap")
                better = next.cost < prev.cost;
            else
                better = next.time + next.transfers * 5 <
                         prev.time + prev.transfers * 5;

            if (better) {
                best.set(key, next);
                pq.push(next);
            }
        }
    }
    return null;
}

/* =======================
   UI
======================= */

let GRAPH, OPERATORS;

document.getElementById("fileInput").addEventListener("change", e => {
    const file = e.target.files[0];
    const reader = new FileReader();
    reader.onload = () => {
        const { graph, stations, operators } = parseRouteFile(reader.result);
        GRAPH = graph;
        OPERATORS = operators;

        const from = document.getElementById("from");
        const to = document.getElementById("to");
        from.innerHTML = to.innerHTML = "";

        stations.forEach(s => {
            from.add(new Option(s, s));
            to.add(new Option(s, s));
        });

        const pricingDiv = document.getElementById("pricing");
        pricingDiv.innerHTML = "";
        operators.forEach(op => {
            pricingDiv.innerHTML +=
                `${op}: <input type="number" id="price_${op}" value="10"><br>`;
        });
    };
    reader.readAsText(file);
});

function compute() {
    const from = document.getElementById("from").value;
    const to = document.getElementById("to").value;

    const pricing = {};
    OPERATORS.forEach(op => {
        pricing[op] = Number(document.getElementById("price_" + op).value);
    });

    const balanced = findPath(GRAPH, from, to, "balanced", pricing);
    const direct = findPath(GRAPH, from, to, "direct", pricing);
    const cheap = findPath(GRAPH, from, to, "cheap", pricing);

    const out = document.getElementById("output");
    out.innerHTML = "";

    renderRoute(out, "Balanced route", balanced);
    renderRoute(out, "Most direct route", direct);
    renderRoute(out, "Cheapest route", cheap);
}

function renderRoute(container, title, r) {
    if (!r) {
        container.innerHTML += `<h3>${title}</h3><p>No route found</p>`;
        return;
    }

    let html = `<h3>${title}</h3>`;
    html += `<p>Time: ${r.time} min | Transfers: ${r.transfers} | Cost: ${r.cost}</p>`;
    html += `<div class="route">`;

    r.path.forEach(p => {
        if (p.transfer) {
            html += `<div class="transfer">Change to ${p.route}</div>`;
        }
        html += `${p.from} â†’ ${p.to} (${p.route}, ${p.time} min)<br>`;
    });

    html += `</div>`;
    container.innerHTML += html;
}
</script>

</body>
</html>
