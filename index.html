<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SCR Route Finder</title>
<style>
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    min-height: 100vh;
    padding: 20px;
}

.container {
    max-width: 1200px;
    margin: 0 auto;
}

.header {
    text-align: center;
    color: white;
    margin-bottom: 30px;
}

.header h1 {
    font-size: 2.5rem;
    font-weight: 700;
    margin-bottom: 10px;
}

.header p {
    font-size: 1.1rem;
    opacity: 0.9;
}

.card {
    background: white;
    border-radius: 12px;
    padding: 25px;
    margin-bottom: 20px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.15);
}

.input-section {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
    margin-bottom: 20px;
}

.input-group {
    display: flex;
    flex-direction: column;
}

.input-group label {
    font-weight: 600;
    margin-bottom: 8px;
    color: #333;
    font-size: 0.9rem;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.input-group select {
    padding: 12px 15px;
    border: 2px solid #e0e0e0;
    border-radius: 8px;
    font-size: 1rem;
    transition: all 0.3s;
    background: white;
    cursor: pointer;
}

.input-group select:focus {
    outline: none;
    border-color: #667eea;
    box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
}

.pricing-section {
    margin-top: 20px;
}

.pricing-section h3 {
    font-size: 1.1rem;
    margin-bottom: 15px;
    color: #333;
}

.pricing-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    gap: 15px;
}

.pricing-item {
    display: flex;
    align-items: center;
    gap: 10px;
}

.pricing-item label {
    font-weight: 600;
    color: #666;
    min-width: 40px;
}

.pricing-item input {
    flex: 1;
    padding: 8px 12px;
    border: 2px solid #e0e0e0;
    border-radius: 6px;
    font-size: 0.95rem;
    transition: all 0.3s;
}

.pricing-item input:focus {
    outline: none;
    border-color: #667eea;
}

.operator-badge {
    display: inline-block;
    padding: 2px 8px;
    border-radius: 4px;
    font-size: 0.75rem;
    font-weight: bold;
    color: white;
}

.operator-CN { background: #0096EE; }
.operator-MT { background: #EE4044; }
.operator-WL { background: #002D5F; }
.operator-AL { background: #EC7D33; }
.operator-EX { background: #FF0080; }

.btn-compute {
    width: 100%;
    padding: 15px;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    border: none;
    border-radius: 8px;
    font-size: 1.1rem;
    font-weight: 600;
    cursor: pointer;
    transition: transform 0.2s, box-shadow 0.2s;
    margin-top: 10px;
}

.btn-compute:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
}

.btn-compute:active {
    transform: translateY(0);
}

.results-container {
    display: grid;
    gap: 20px;
}

.route-card {
    background: white;
    border-radius: 12px;
    padding: 25px;
    box-shadow: 0 5px 20px rgba(0,0,0,0.1);
    border-left: 5px solid #667eea;
}

.route-card h3 {
    font-size: 1.4rem;
    margin-bottom: 15px;
    color: #333;
}

.route-stats {
    display: flex;
    gap: 20px;
    margin-bottom: 20px;
    flex-wrap: wrap;
}

.stat {
    display: flex;
    align-items: left;
    gap: 8px;
    padding: 8px 15px;
    background: #f8f9fa;
    border-radius: 6px;
    font-size: 0.95rem;
}

.stat-label {
    font-weight: 600;
    color: #666;
}

.stat-value {
    font-weight: 700;
    color: #333;
}

.route-path {
    background: #f8f9fa;
    border-radius: 8px;
    padding: 15px;
}

.route-step {
    display: flex;
    align-items: left;
    padding: 10px;
    margin-bottom: 8px;
    background: white;
    border-radius: 6px;
    transition: all 0.2s;
}

.route-step:hover {
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

.route-step:last-child {
    margin-bottom: 0;
}

.route-step .segment-container {
    display: block; /* ensures it goes below the badges */
    margin-top: 6px;
}

.route-step .segment-stops {
    margin: 6px 0 0 20px;
    font-size: 0.85rem;
    color: #555;
}

.route-step .segment-toggle {
    cursor: pointer;
    color: #667eea;
    font-weight: 600;
    font-size: 0.8rem;
    user-select: none;
}

.route-step .segment-toggle:hover {
    text-decoration: underline;
}

.route-step .hidden {
    display: none;
}


.step-icon {
    width: 8px;
    height: 8px;
    background: #667eea;
    border-radius: 50%;
    margin-right: 12px;
}

.step-details {
    flex: 1;
    display: flex;
    align-items: center;
    gap: 10px;
    flex-wrap: wrap;
}

.step-stations {
    font-weight: 600;
    color: #333;
}

.step-time {
    color: #666;
    font-size: 0.9rem;
}

.transfer-badge {
    background: #afac05;
    color: white;
    padding: 4px 12px;
    border-radius: 20px;
    font-size: 0.85rem;
    font-weight: 600;
    margin: 10px 0;
    display: inline-block;
}

.no-route {
    text-align: center;
    padding: 30px;
    color: #999;
    font-size: 1.1rem;
}

.loading {
    text-align: center;
    padding: 40px;
    color: white;
    font-size: 1.2rem;
}
.segment-stops {
    margin: 6px 0 0 20px;
    font-size: 0.85rem;
    color: #555;
}

.segment-toggle {
    cursor: pointer;
    color: #667eea;
    font-weight: 600;
    font-size: 0.8rem;
    user-select: none;
}
.segment-stops div {
    margin-left: 15px;
    padding: 2px 0;
}


.segment-toggle:hover {
    text-decoration: underline;
}
.hidden {
    display: none;
}
.step-details {
    display: flex;
    flex-direction: column; /* force vertical stacking */
    gap: 6px;
}

.segment-main {
    display: flex;
    align-items: left;
    flex-wrap: wrap;
    gap: 10px;
}



@media (max-width: 768px) {
    .input-section {
        grid-template-columns: 1fr;
    }
    
    .header h1 {
        font-size: 1.8rem;
    }
    
    .pricing-grid {
        grid-template-columns: 1fr;
    }
}
</style>
</head>
<body>

<div class="container">
    <div class="header">
        <h1>üöÜ SCR Route Finder</h1>
        <p>Stepford County Railway - Plan your journey</p>
    </div>

    <div class="card">
        <div class="input-section">
            <div class="input-group">
                <label>From Station</label>
                <select id="from">
                    <option value="">Select departure...</option>
                </select>
            </div>
            <div class="input-group">
                <label>To Station</label>
                <select id="to">
                    <option value="">Select arrival...</option>
                </select>
            </div>
        </div>

        <div class="pricing-section">
            <h3>üí∞ Operator Pricing (per station)</h3>
            <div class="pricing-grid" id="pricing"></div>
        </div>

        <button class="btn-compute" onclick="compute()">Find Routes</button>
    </div>

    <div class="results-container" id="output"></div>
</div>


    
<script>
/* =======================
   PARSE route.txt
======================= */
const DEFAULT_OPERATOR_PRICES = {
    CN: 5,
    MT: 3,
    WL: 7,
    AL: 10,
    EX: 15
};
const ROUTE_INDEX = new Map();

function parseRouteFile(text) {
    
    const graph = new Map();
    const stations = new Set();
    const operators = new Set();

    function addEdge(from, to, route, operator, time) {
        if (!graph.has(from)) graph.set(from, []);
        graph.get(from).push({ to, route, operator, time });
    }

    const routes = text.split("//").filter(r => r.trim());

    for (const r of routes) {
        const [operator, routeId, stationPart] = r.split("/");
        operators.add(operator);

        const list = stationPart.split(";").map(s => {
            const [name, t] = s.split(",");
            return { name, time: Number(t) };
        });

        /* === BUILD ROUTE INDEX (ORDERED STOPS) === */
        ROUTE_INDEX.set(routeId, {
            operator,
            stations: list.map(x => x.name)
        });

        for (let i = 0; i < list.length - 1; i++) {
            const a = list[i];
            const b = list[i + 1];
            const dt = b.time - a.time;

            addEdge(a.name, b.name, routeId, operator, dt);
            addEdge(b.name, a.name, routeId, operator, dt);

            stations.add(a.name);
            stations.add(b.name);
        }
    }

    return { graph, stations: [...stations].sort(), operators: [...operators].sort() };
}


/* =======================
   PRIORITY QUEUE
======================= */

class PriorityQueue {
    constructor(compare) {
        this.data = [];
        this.compare = compare;
    }
    push(x) {
        this.data.push(x);
        this.data.sort(this.compare);
    }
    pop() {
        return this.data.shift();
    }
    get size() {
        return this.data.length;
    }
}

/* =======================
   PATHFINDING
======================= */

function findPath(graph, from, to, mode, pricing) {
    const TRANSFER_PENALTY = 5;

    const pq = new PriorityQueue((a, b) => {
        if (mode === "direct") {
            if (a.transfers !== b.transfers)
                return a.transfers - b.transfers;
            return a.time - b.time;
        }
        if (mode === "cheap") {
            if (a.cost !== b.cost) return a.cost - b.cost;
            return a.time - b.time;  // tie-breaker: prefer faster
        }
        return (a.time + a.transfers * TRANSFER_PENALTY) -
               (b.time + b.transfers * TRANSFER_PENALTY);
    });

    const best = new Map();

    for (const e of graph.get(from) || []) {
        const s = {
            station: from,
            route: e.route,
            operator: e.operator,
            time: 0,
            transfers: 0,
            cost: 0,
            path: []
        };
        best.set(from + "|" + e.route, s);
        pq.push(s);
    }

    while (pq.size) {
        const cur = pq.pop();
        if (cur.station === to) return cur;

        for (const e of graph.get(cur.station) || []) {
            const transfer = e.route !== cur.route;
            const next = {
                station: e.to,
                route: e.route,
                operator: e.operator,
                time: cur.time + e.time,
                transfers: cur.transfers + (transfer ? 1 : 0),
                cost: cur.cost + (pricing[e.operator] || 0),
                path: cur.path.concat({
                    from: cur.station,
                    to: e.to,
                    route: e.route,
                    operator: e.operator,
                    time: e.time,
                    transfer
                })
            };

            const key = e.to + "|" + e.route;
            const prev = best.get(key);

            let better = false;
            if (!prev) {
                better = true;
            } else if (mode === "direct") {
                // For direct mode: fewer transfers wins, then faster time
                better = next.transfers < prev.transfers ||
                         (next.transfers === prev.transfers && next.time < prev.time);
            } else if (mode === "cheap") {
                // For cheap mode: lower cost wins, then faster time
                better = next.cost < prev.cost ||
                         (next.cost === prev.cost && next.time < prev.time);
            } else {
                // For balanced mode: use combined score
                better = (next.time + next.transfers * TRANSFER_PENALTY) <
                         (prev.time + prev.transfers * TRANSFER_PENALTY);
            }

            if (better) {
                best.set(key, next);
                pq.push(next);
            }
        }
    }
    return null;
}


function findEquivalentRoutesForSegment(segment) {
    const refStops = segment.stations.join(">");
    const result = [];

    for (const [routeId, info] of ROUTE_INDEX.entries()) {
        if (info.operator !== segment.operator) continue;

        const i = info.stations.indexOf(segment.from);
        const j = info.stations.indexOf(segment.to);
        if (i < 0 || j <= i) continue;

        const slice = info.stations.slice(i, j + 1).join(">");
        if (slice === refStops) {
            result.push(routeId);
        }
    }

    return result;
}

/* =======================
   UI
======================= */

let GRAPH, OPERATORS, STATION_NAMES;

// Load station names first
fetch("station.txt")
    .then(r => r.text())
    .then(text => {
        STATION_NAMES = {};
        const entries = text.split("/").filter(e => e.trim());
        entries.forEach(entry => {
            const [code, name] = entry.split(";");
            if (code && name) {
                STATION_NAMES[code.trim()] = name.trim();
            }
        });
        
        // Then load routes
        return fetch("route.txt");
    })
    .then(r => r.text())
    .then(text => {
        const { graph, stations, operators } = parseRouteFile(text);
        GRAPH = graph;
        OPERATORS = operators;

        const from = document.getElementById("from");
        const to = document.getElementById("to");

        stations.forEach(s => {
            const displayName = STATION_NAMES[s] ? `${s} - ${STATION_NAMES[s]}` : s;
            from.add(new Option(displayName, s));
            to.add(new Option(displayName, s));
        });

        const pricingDiv = document.getElementById("pricing");
        operators.forEach(op => {
            const defaultPrice = DEFAULT_OPERATOR_PRICES[op] ?? 10;
        
            pricingDiv.innerHTML += `
                <div class="pricing-item">
                    <label class="operator-badge operator-${op}">${op}</label>
                    <input
                        type="number"
                        id="price_${op}"
                        value="${defaultPrice}"
                        min="0"
                    >
                </div>
            `;
        });

    })
    .catch(err => {
        document.body.innerHTML = `
            <div class="container">
                <div class="card">
                    <h2 style="color: #e74c3c;">‚ùå Failed to load data files</h2>
                    <p>Make sure route.txt and station.txt are in the same directory.</p>
                    <p style="color: #999; font-size: 0.9rem;">${err.message}</p>
                </div>
            </div>
        `;
        console.error(err);
    });

function compute() {
    const from = document.getElementById("from").value;
    const to = document.getElementById("to").value;

    if (!from || !to) {
        alert("Please select both departure and arrival stations");
        return;
    }

    const pricing = {};
    OPERATORS.forEach(op => {
        pricing[op] = Number(document.getElementById("price_" + op).value);
    });

    const out = document.getElementById("output");
    out.innerHTML = "";

    render("‚öñÔ∏è Balanced Route", findPath(GRAPH, from, to, "balanced", pricing), "#667eea");
    render("üöÄ Most Direct Route", findPath(GRAPH, from, to, "direct", pricing), "#2ecc71");
    render("üí∞ Cheapest Route", findPath(GRAPH, from, to, "cheap", pricing), "#f39c12");
}
function extractSegments(path) {
    const segments = [];
    let current = null;

    for (const step of path) {
        if (!current || step.transfer) {
            if (current) segments.push(current);
            current = {
                route: step.route,
                operator: step.operator,
                from: step.from,
                to: step.to,
                stations: [step.from, step.to],
                steps: [step],   // store actual steps for timing
                time: step.time  // initialize time
            };
        } else {
            current.to = step.to;
            current.stations.push(step.to);
            current.steps.push(step);
            current.time += step.time;  // accumulate time
        }
    }

    if (current) segments.push(current);
    return segments;
}

function render(title, r, color) {
    const out = document.getElementById("output");

    if (!r) {
        out.innerHTML += `
            <div class="route-card" style="border-left-color: ${color}">
                <h3>${title}</h3>
                <div class="no-route">No route found</div>
            </div>`;
        return;
    }

    const getDisplayName = c =>
        STATION_NAMES[c] ? `${c} - ${STATION_NAMES[c]}` : c;

    let html = `
        <div class="route-card" style="border-left-color: ${color}">
            <h3>${title}</h3>

            <div class="route-stats">
                <div class="stat"><span class="stat-label">‚è±Ô∏è</span>${r.time} min</div>
                <div class="stat"><span class="stat-label">üîÑ</span>${r.transfers}</div>
                <div class="stat"><span class="stat-label">üíµ</span>${r.cost}</div>
            </div>

            <div class="route-path">
    `;

    const segments = extractSegments(r.path);

    segments.forEach((seg, idx) => {
        if (idx > 0) {
            html += `<div class="transfer-badge">üîÑ Transfer</div>`;
        }
    
        const stopId = `stops_${title}_${idx}`.replace(/\s+/g, "_");
    
        // Find equivalent routes
        const equivalents = findEquivalentRoutesForSegment(seg)
            .filter(id => id !== seg.route);
    
        html += `
            <div class="route-step">
                <div class="step-icon"></div>
                <div class="step-details">
                    <!-- Block for main segment info -->
                    <div class="segment-main">
                        <span class="step-stations">
                            ${getDisplayName(seg.from)} ‚Üí ${getDisplayName(seg.to)}
                        </span>
                        <span class="operator-badge operator-${seg.operator}">${seg.route}</span>
                        ${equivalents.map(id => `<span class="operator-badge operator-${seg.operator}">${id}</span>`).join("")}
                        <span class="step-time">${seg.time || ""} min</span>
                    </div>
            
                    <!-- Block for toggle and stops -->
                    <div class="segment-container">
                        <div class="segment-toggle"
                             onclick="document.getElementById('${stopId}').classList.toggle('hidden')">
                             ‚ñº Show all stops (${seg.stations.length})
                        </div>
                        <div id="${stopId}" class="segment-stops hidden">
                            ${seg.stations.map(s => `<div>${getDisplayName(s)}</div>`).join("")}
                        </div>
                    </div>
                </div>
            </div>

        `;
    });
    html += `</div>`; // closes route-path
    out.innerHTML += html;
}

</script>

</body>
</html>
