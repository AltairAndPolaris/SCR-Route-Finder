<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SCR Route Finder</title>
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useMemo, useEffect } = React;

        // Lucide icons as inline SVG components
        const Train = () => (
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <rect x="4" y="6" width="16" height="14" rx="2"/>
                <path d="M4 11h16"/>
                <path d="M12 6v5"/>
                <circle cx="9" cy="17" r="1"/>
                <circle cx="15" cy="17" r="1"/>
            </svg>
        );

        const ArrowRight = () => (
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <line x1="5" y1="12" x2="19" y2="12"/>
                <polyline points="12 5 19 12 12 19"/>
            </svg>
        );

        const Clock = () => (
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <circle cx="12" cy="12" r="10"/>
                <polyline points="12 6 12 12 16 14"/>
            </svg>
        );

        const Users = () => (
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/>
                <circle cx="9" cy="7" r="4"/>
                <path d="M23 21v-2a4 4 0 0 0-3-3.87"/>
                <path d="M16 3.13a4 4 0 0 1 0 7.75"/>
            </svg>
        );

        const Transfer = () => (
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <polyline points="17 1 21 5 17 9"/>
                <path d="M3 11V9a4 4 0 0 1 4-4h14"/>
                <polyline points="7 23 3 19 7 15"/>
                <path d="M21 13v2a4 4 0 0 1-4 4H3"/>
            </svg>
        );

        const SCRRouteFinder = () => {
            const [routeData, setRouteData] = useState('');
            const [loading, setLoading] = useState(true);
            const [error, setError] = useState(null);
            const [fromStation, setFromStation] = useState('');
            const [toStation, setToStation] = useState('');
            const [routes, setRoutes] = useState(null);

            // Load route data from route.txt
            useEffect(() => {
                fetch('route.txt')
                    .then(response => {
                        if (!response.ok) {
                            throw new Error('Could not load route.txt');
                        }
                        return response.text();
                    })
                    .then(data => {
                        setRouteData(data);
                        setLoading(false);
                    })
                    .catch(err => {
                        setError(err.message);
                        setLoading(false);
                    });
            }, []);

            // Parse route data
            const { routesList, stations, graph } = useMemo(() => {
                if (!routeData) {
                    return { routesList: [], stations: [], graph: new Map() };
                }

                const routesList = [];
                const stationsSet = new Set();
                const graph = new Map();

                const routeStrings = routeData.split('//').filter(r => r.trim());
                
                routeStrings.forEach(routeStr => {
                    const [operator, code, stationsStr] = routeStr.split('/');
                    if (!operator || !code || !stationsStr) return;

                    const stationList = stationsStr.split(';').map(s => {
                        const [name, time] = s.split(',');
                        return { name: name.trim(), time: parseInt(time) };
                    });

                    routesList.push({
                        operator,
                        code,
                        stations: stationList
                    });

                    stationList.forEach(s => stationsSet.add(s.name));

                    for (let i = 0; i < stationList.length; i++) {
                        const station = stationList[i].name;
                        if (!graph.has(station)) {
                            graph.set(station, []);
                        }

                        if (i < stationList.length - 1) {
                            const nextStation = stationList[i + 1].name;
                            const timeDiff = stationList[i + 1].time - stationList[i].time;
                            graph.get(station).push({
                                to: nextStation,
                                time: timeDiff,
                                route: code,
                                operator
                            });
                        }

                        if (i > 0) {
                            const prevStation = stationList[i - 1].name;
                            const timeDiff = stationList[i].time - stationList[i - 1].time;
                            graph.get(station).push({
                                to: prevStation,
                                time: timeDiff,
                                route: code,
                                operator
                            });
                        }
                    }
                });

                return {
                    routesList,
                    stations: Array.from(stationsSet).sort(),
                    graph
                };
            }, [routeData]);

            // Generic pathfinding with configurable transfer penalty
            const findPath = (transferPenalty, debug = false) => {
                const distances = new Map();
                const previous = new Map();
                const transferCount = new Map(); // Track number of transfers to each station
                const unvisited = new Set(stations);

                stations.forEach(s => {
                    distances.set(s, Infinity);
                    transferCount.set(s, Infinity);
                });
                distances.set(fromStation, 0);
                transferCount.set(fromStation, 0);

                while (unvisited.size > 0) {
                    let current = null;
                    let minDist = Infinity;
                    
                    for (const station of unvisited) {
                        if (distances.get(station) < minDist) {
                            minDist = distances.get(station);
                            current = station;
                        }
                    }

                    if (current === null || current === toStation) break;
                    
                    unvisited.delete(current);

                    const neighbors = graph.get(current) || [];
                    const currentRoute = previous.get(current)?.route;
                    const currentTransfers = transferCount.get(current);
                    
                    if (debug && current === fromStation) {
                        console.log(`From ${fromStation}, neighbors:`, neighbors);
                    }
                    
                    for (const neighbor of neighbors) {
                        if (!unvisited.has(neighbor.to)) continue;
                        
                        // Count transfers: if we have a current route and neighbor is different route, that's a transfer
                        const isTransfer = currentRoute && currentRoute !== neighbor.route;
                        const newTransfers = currentTransfers + (isTransfer ? 1 : 0);
						const newDist =
							distances.get(current)
							+ neighbor.time
							+ (isTransfer ? transferPenalty : 0);

                        
                        // For cumulative distance tracking
                        const cumulativeDist = distances.get(current) + neighbor.time + (isTransfer ? transferPenalty : 0);
                        
                        if (debug && current === fromStation) {
                            console.log(`  â†’ ${neighbor.to} via ${neighbor.route}: ${neighbor.time} min, transfers: ${newTransfers}, penalty: ${penalty}, total: ${neighbor.time + penalty}`);
                        }
                        
                        if (newDist < distances.get(neighbor.to)) {
							distances.set(neighbor.to, newDist);
							transferCount.set(neighbor.to, newTransfers);
							previous.set(neighbor.to, {
								station: current,
								route: neighbor.route,
								operator: neighbor.operator,
								time: neighbor.time
							});
						}

                    }
                }

                if (!previous.has(toStation)) {
                    return null;
                }

                const path = [];
                let current = toStation;
                
                while (previous.has(current)) {
                    const prev = previous.get(current);
                    path.unshift({
                        from: prev.station,
                        to: current,
                        route: prev.route,
                        operator: prev.operator,
                        time: prev.time
                    });
                    current = prev.station;
                }

                const segments = [];
                let currentSegment = null;

                path.forEach(step => {
                    if (!currentSegment || currentSegment.route !== step.route) {
                        if (currentSegment) segments.push(currentSegment);
                        currentSegment = {
                            route: step.route,
                            operator: step.operator,
                            stations: [step.from, step.to],
                            time: step.time
                        };
                    } else {
                        currentSegment.stations.push(step.to);
                        currentSegment.time += step.time;
                    }
                });
                if (currentSegment) segments.push(currentSegment);

                const actualTime = path.reduce((sum, step) => sum + step.time, 0);
                const transfers = segments.length - 1;

                return {
                    segments,
                    actualTime,
                    transfers
                };
            };

            const findAllRoutes = () => {
                if (!fromStation || !toStation || fromStation === toStation) {
                    setRoutes(null);
                    return;
                }

                // Find three different route options
                const bestRoute = findPath(2, false); // Balanced (2 min penalty per transfer)
                const fastestRoute = findPath(0, false); // Pure shortest time (no transfer penalty)
                const shortestRoute = findPath(1000, true); // Very heavy penalty = absolute preference for fewest transfers

                if (!bestRoute && !fastestRoute && !shortestRoute) {
                    setRoutes({ error: 'No route found' });
                    return;
                }

                // Remove duplicates (if routes are identical)
                const allRoutes = [
                    { type: 'best', label: 'Best Route', description: 'Balanced time and transfers', route: bestRoute },
                    { type: 'fastest', label: 'Fastest Route', description: 'Least time', route: fastestRoute },
                    { type: 'shortest', label: 'Shortest Route', description: 'Fewest transfers', route: shortestRoute }
                ].filter(r => r.route);

                setRoutes(allRoutes);
            };

            const operatorColors = {
                'CN': 'bg-blue-500',
                'MT': 'bg-red-500',
                'WL': 'bg-cyan-500',
                'AL': 'bg-purple-500',
                'EX': 'bg-green-500'
            };

            const RouteDisplay = ({ type, label, description, route }) => {
                const badgeColors = {
                    'best': 'bg-gradient-to-r from-indigo-500 to-purple-500',
                    'fastest': 'bg-gradient-to-r from-green-500 to-emerald-500',
                    'shortest': 'bg-gradient-to-r from-blue-500 to-cyan-500'
                };

                return (
                    <div className="bg-white rounded-lg shadow-xl p-6 mb-4">
                        <div className="flex items-center justify-between mb-4 pb-4 border-b">
                            <div>
                                <div className={`inline-block ${badgeColors[type]} text-white px-4 py-2 rounded-full text-sm font-bold mb-2`}>
                                    {label}
                                </div>
                                <p className="text-gray-600 text-sm">{description}</p>
                            </div>
                            <div className="text-right">
                                <div className="flex items-center gap-2 text-gray-800">
                                    <Clock />
                                    <span className="text-2xl font-bold">{route.actualTime} min</span>
                                </div>
                                <div className="flex items-center gap-2 text-gray-600 mt-1">
                                    <Transfer />
                                    <span className="text-sm">{route.transfers} transfer{route.transfers !== 1 ? 's' : ''}</span>
                                </div>
                            </div>
                        </div>

                        <div className="space-y-6">
                            {route.segments.map((segment, idx) => (
                                <div key={idx}>
                                    <div className="flex items-center gap-3 mb-3">
                                        <div className={`${operatorColors[segment.operator] || 'bg-gray-500'} text-white px-3 py-1 rounded-full text-sm font-semibold`}>
                                            {segment.route}
                                        </div>
                                        <div className="flex items-center gap-2 text-gray-600">
                                            <Users />
                                            <span className="text-sm">{segment.operator}</span>
                                        </div>
                                        <div className="flex items-center gap-2 text-gray-600">
                                            <Clock />
                                            <span className="text-sm">{segment.time} min</span>
                                        </div>
                                    </div>

                                    <div className="ml-4 pl-4 border-l-4 border-gray-300">
                                        {segment.stations.map((station, sIdx) => (
                                            <div key={sIdx} className="flex items-center gap-3 py-2">
                                                <div className={`w-3 h-3 rounded-full ${operatorColors[segment.operator] || 'bg-gray-500'}`}></div>
                                                <span className="font-medium text-gray-800">{station}</span>
                                                {sIdx === 0 && segment.stations.length > 2 && (
                                                    <span className="text-sm text-gray-500">(Board here)</span>
                                                )}
                                                {sIdx === segment.stations.length - 1 && idx < route.segments.length - 1 && (
                                                    <span className="text-sm text-indigo-600 font-semibold">(Transfer)</span>
                                                )}
                                                {sIdx === segment.stations.length - 1 && idx === route.segments.length - 1 && (
                                                    <span className="text-sm text-green-600 font-semibold">(Arrive)</span>
                                                )}
                                            </div>
                                        ))}
                                    </div>

                                    {idx < route.segments.length - 1 && (
                                        <div className="flex items-center gap-2 my-4 text-indigo-600">
                                            <ArrowRight />
                                            <span className="font-semibold">Change to {route.segments[idx + 1].route}</span>
                                        </div>
                                    )}
                                </div>
                            ))}
                        </div>
                    </div>
                );
            };

            if (loading) {
                return (
                    <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 flex items-center justify-center">
                        <div className="text-center">
                            <div className="inline-block animate-spin rounded-full h-12 w-12 border-b-2 border-indigo-600 mb-4"></div>
                            <p className="text-gray-600">Loading route data...</p>
                        </div>
                    </div>
                );
            }

            if (error) {
                return (
                    <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 flex items-center justify-center">
                        <div className="bg-white rounded-lg shadow-xl p-8 max-w-md">
                            <h2 className="text-xl font-bold text-red-600 mb-4">Error Loading Data</h2>
                            <p className="text-gray-600 mb-4">{error}</p>
                            <p className="text-sm text-gray-500">Make sure <code className="bg-gray-100 px-2 py-1 rounded">route.txt</code> is in the same folder as this HTML file.</p>
                        </div>
                    </div>
                );
            }

            return (
                <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 p-6">
                    <div className="max-w-4xl mx-auto">
                        <div className="bg-white rounded-lg shadow-xl p-8 mb-6">
                            <div className="flex items-center gap-3 mb-6">
                                <Train />
                                <h1 className="text-3xl font-bold text-gray-800">SCR Route Finder</h1>
                            </div>
                            
                            <p className="text-gray-600 mb-6">Stepford County Railway - Find the best route between stations</p>

                            <div className="grid md:grid-cols-2 gap-4 mb-6">
                                <div>
                                    <label className="block text-sm font-medium text-gray-700 mb-2">From Station</label>
                                    <select 
                                        className="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-transparent"
                                        value={fromStation}
                                        onChange={(e) => setFromStation(e.target.value)}
                                    >
                                        <option value="">Select station...</option>
                                        {stations.map(s => (
                                            <option key={s} value={s}>{s}</option>
                                        ))}
                                    </select>
                                </div>

                                <div>
                                    <label className="block text-sm font-medium text-gray-700 mb-2">To Station</label>
                                    <select 
                                        className="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-transparent"
                                        value={toStation}
                                        onChange={(e) => setToStation(e.target.value)}
                                    >
                                        <option value="">Select station...</option>
                                        {stations.map(s => (
                                            <option key={s} value={s}>{s}</option>
                                        ))}
                                    </select>
                                </div>
                            </div>

                            <button
                                onClick={findAllRoutes}
                                disabled={!fromStation || !toStation}
                                className="w-full bg-indigo-600 text-white py-3 rounded-lg font-semibold hover:bg-indigo-700 disabled:bg-gray-300 disabled:cursor-not-allowed transition-colors"
                            >
                                Find Routes
                            </button>
                        </div>

                        {routes && (
                            <>
                                {routes.error ? (
                                    <div className="bg-white rounded-lg shadow-xl p-8">
                                        <p className="text-red-600 text-center">{routes.error}</p>
                                    </div>
                                ) : (
                                    <>
                                        <h2 className="text-2xl font-bold text-gray-800 mb-4">Route Options</h2>
                                        {routes.map((item, idx) => (
                                            <RouteDisplay 
                                                key={idx}
                                                type={item.type}
                                                label={item.label}
                                                description={item.description}
                                                route={item.route}
                                            />
                                        ))}
                                    </>
                                )}
                            </>
                        )}

                        <div className="mt-6 bg-white rounded-lg shadow-xl p-6">
                            <h3 className="font-semibold text-gray-800 mb-2">How to add more routes:</h3>
                            <p className="text-sm text-gray-600">
                                Edit <code className="bg-gray-100 px-2 py-1 rounded">route.txt</code> and add your routes following this format:<br/>
                                <code className="bg-gray-100 px-2 py-1 rounded text-xs">Operator/RouteCode/Station1,time;Station2,time;//</code>
                            </p>
                            <p className="text-sm text-gray-500 mt-2">Currently loaded: {routesList.length} routes, {stations.length} stations</p>
                        </div>
                    </div>
                </div>
            );
        };

        ReactDOM.render(<SCRRouteFinder />, document.getElementById('root'));
    </script>
</body>
</html>
